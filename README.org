# -*- Mode: org -*-
Matlisp is a scientific computation library for Common Lisp. Lisp is generally a wonderful language
for explorative computing, but often lacks tools for numerical computing. This project is an attempt
at plugging this perceived shortcoming.

* Overview
  Lisp allows interesting new constructs without being tied down to a particular language vendor,
  and we make full use of this facility. Most classes/methods are dynamically generated in Matlisp.
  Custom method dispatch under MOP allows us to treat templates and CLOS methods without much
  difference.

  Matlisp provides an infix reader for evaluating mathematical expressions. We use '/' as both a binary
  and unary operator within matlisp's infix reader, this allows us to ensure semantic uniformity even when
  dealing with non-commutativity rings.

  Solving $A x = b$ is consequently as simple as,
  #+BEGIN_SRC lisp
  MATLISP> #i(/A * b)
  #+END_SRC
  , this operation being generic to A being a scalar/matrix/permutation. It's also extremely simple to define
  custom syntax by tweaking "src/reader/infix.lisp".

  For a variety of reasons, Matlisp duplicates general BLAS functionality using Lisp code. These are similar to
  the naive-loop versions found in the BLAS reference implementation, but are generated using macros, and are
  consequently quite terse. These macro expand into lean code blocks which are often very competitive (within
  10-20%) of the corresponding C code. This allows users greater flexibility when dealing with specific
  problems. For instance GEMM is essentially generated by the following code-snippet (exercise: why 'j k i' ?),
  #+BEGIN_SRC lisp
   > (defun mm (A B C)
       (einstein-sum #.(tensor 'double-float) (j k i) (ref C i j) (* (ref A i j) (ref B j k))))
  #+END_SRC
  Matlisp also switches dynamically between BLAS routines (when available) and native lisp
  code to avoid FFI overheads. This functionality can be used (with minimal tweaking) without the need for
  a a BLAS library, or for commutative-ring types which don't have BLAS routines available.

* Dependencies
- CFFI
  Matlisp uses CFFI for interfacing with foreign libraries. CFFI support varies between lisp implementations;
  Matlisp assumes that certain simple-vectors in the lisp implementation are in unboxed form, and have a SAP
  that can be passed to Fortran functions. It might be possible to replace this with static/pinned arrays, as
  is kind-of done a the moment for foreign dense-tensor.

  Most of the BLAS functionality is duplicated in native lisp code, and so one can very possibly run Matlisp
  without any foreign libraries (but at the cost of losing all LAPACK functionality).

  CFFI is provided by quicklisp.

- MOP
  Matlisp now uses the Meta-Object protocol to generate and maintain classes & methods. This is *not* in the 
  ANSI standard, and consequently only seems to work now on SBCL. Clozure seems to have strange bugs, which
  need fixing; your luck with other implementations may wary.

* Install
  Matlisp has been successfully built on SBCL. Getting it running is thematic of quicklisp,
- Install quicklisp http://www.quicklisp.org/beta/.
- Download matlisp source:
#+BEGIN_SRC shell
   > git clone git@github.com:matlisp/matlisp.git
   > ln -s $PWD/matlisp <quicklisp-directory>/local-projects
#+END_SRC
Fire up your lisp implementation and load as usual with quicklisp:
#+BEGIN_SRC lisp
  CL-USER> (ql:quickload :matlisp)
  CL-USER> (in-package :matlisp)
  M> (named-readtables:in-readtable :infix-dispatch-table)
#+END_SRC

* Example
  #+BEGIN_SRC lisp
  ;;Creation
  M> (copy! (randn '(2 2)) (zeros '(2 2) '((complex double-float))))
  #<|(COMPLEX DOUBLE-FLOAT) STRIDE-ACCESSOR SIMPLE-ARRAY| #(2 2)
    0.8492   -1.976
    2.207    -1.251
  >
  ;;gemv
  M> (let ((a (randn '(2 2)))
	   (b (randn 2)))
       #i(a * b))
  #<|DOUBLE-FLOAT STRIDE-ACCESSOR SIMPLE-ARRAY| #(2)
  1.1885     0.95746
  >

  ;;Tensor contraction
  M> (let ((H (randn '(2 2 2)))
	   (b (randn 2))
	   (c (randn 2))
	   (f (zeros 2)))
	   ;;#i(H @ b @ c)
       (einstein-sum #.(tensor 'double-float) (i j k) (ref f i) (* (ref H i j k) (ref b j) (ref c k))))
  #<|DOUBLE-FLOAT STRIDE-ACCESSOR SIMPLE-ARRAY| #(2)
  0.62586     -1.1128
  >
  ;;Similarly
  M> (let ((H (randn '(2 2 2))))
       #i(H @ randn(2) @ randn(2)))
  #<|DOUBLE-FLOAT STRIDE-ACCESSOR SIMPLE-ARRAY| #(2)
   0.3234  -0.6201
  >
  #+END_SRC

* Documentation
  More documentation will be added as the project reaches a stable state.

* Enchancements
- [[https://github.com/matlisp/matlisp-forbi][matlisp-forbi]]
  The API for BLAS functions dot ensures inconsistent ABIs between compilers. This package provides a Fortran wrapper (and Lisp methods for `dot`) that fixes these issues. It also provides F77 methods for elementwise division, which follow the `scal` API.e

- Weyl
  Weyl is a CAS written in Lisp (and for Lisp!) at Cornell by Richard Zippel's group. Currently, this used only within
  'src;base;symbolic.lisp' (and assoc. infix readers), for working with symbolic expressions. In order to use this functionality,
  Weyl must be loaded before Matlisp.

  [[https://github.com/matlisp/weyl][Weyl]] can installed from 'git@github.com:matlisp/weyl.git'.

* Tracker
** Completed
   * Dynamic class/method generation, using MOP
   * Complete BLAS/LAPACK functionality for types double-float, single-float, (complex single-float), (complex double-float).
   * Partial support for dense-tensor with a foreign-pointer store.
   * Inplace slicing, real-imaginary part views, negative strides for dense-tensors.
   * permutations, sorting, conversion between action/cycle/flip representations.
   * Optimized loop generators (einstein/iterate for-mod) in Lisp; BLAS functionality duplicated, and switches automatically b/w Lisp and Fortran.
   * Arbitrary tensor contraction.
   * Graphs: a general CCS/CCR matrix implementation, lisp adjacency list support, iterate macros for DFS/BFS/SFD graph-traversal, tree-decomposition,
     cholesky-covers, maximum acyclic subgraph, Djikstra's algorithms.
   * Data structures: Fibonacci heap, Union-Find structure, minimal Doubly linked lists.
   * Hash-table sparse tensor: O(1) read/write.
   * Co-ordinate sparse tensor

** TODO Incomplete/Planned
- Random distributions
  Implementing a fast, automated version of [[http://www.jstatsoft.org/article/view/v005i08/ziggurat.pdf][Ziggurat]] algorithm. Given a sampler for the tail of the distribution and the
  form of the density function, it should be theoretically possible to generate a Ziggurat sampler.
- Unify slicing syntax
  Unify the slicing syntax used by iterate for-mod/einstein macros. Unify these with a more powerful language.
- Automatic Differentiation
- Symbolic Integration
  Needs extensive hacking of Weyl.
- Gnuplot interface
- (C)Python-bridge
- FiveAM tests

* Emacs
Matlisp uses a variety of Unicode symbols for some function names and certain operators in the infix reader.
The user can readily change these to his suiting, or instead use the following Emacs shortcuts to enter these
characters.

#+BEGIN_SRC lisp
;; Lisp
(defun add-lisp-slime-hook (func)
  (add-hook 'lisp-mode-hook func)
  (add-hook 'slime-repl-mode-hook func))
;;#\GREEK_SMALL_LETTER_LAMDA is bound to lambda in :infix-dispatch-table; inherited from λ-reader
(add-lisp-slime-hook #'(lambda () (local-set-key (kbd "C-c \\") (lambda () (interactive (insert "λ"))))))
;;#\LONG_RIGHTWARDS_ARROW_FROM_BAR used for anonymous function definition in Infix
;;#i([x] ⟼ x + 1)
(add-lisp-slime-hook #'(lambda () (local-set-key (kbd "C-c /") (lambda () (interactive (insert "⟼"))))))
;;#\CIRCLE_TIMES used for tensor-product in Infix
(add-lisp-slime-hook #'(lambda () (local-set-key (kbd "C-c *") (lambda () (interactive (insert "⊗"))))))
;;#\MIDDLE_DOT used for tensor-contraction (also bound is @) in Infix
(add-lisp-slime-hook #'(lambda () (local-set-key (kbd "C-c .") (lambda () (interactive (insert "·"))))))
;;Used in the function `(δ-i g &optional i j)` in graph-accessor.lisp
(add-lisp-slime-hook #'(lambda () (local-set-key (kbd "C-c a") (lambda () (interactive (insert "δ"))))))
;;#\DEVANAGARI_LETTER_SA used in infix for tensors involving symbolic expressions.
(add-lisp-slime-hook #'(lambda () (local-set-key (kbd "C-c s") (lambda () (interactive (insert "स"))))))
#+END_SRC
