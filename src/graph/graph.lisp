(in-package :matlisp)

(defun graph->adlist (g)
  (declare (type graph-accessor g))
  (iter (for i from 0 below (1- (length (fence g))))
	(collect (δ-i g i t) result-type vector)))

(defun adlist->graph (ag &optional type)
  (let*-typed ((nnz (iter (for ai in-vector ag) (summing (length ai))))
	       (ret (zeros (list (length ag) (length ag)) (or type 'graph-accessor) nnz) :type graph-accessor)
	       (fe (fence ret))
	       (nv (δ-i ret)))
    (iter (for i from 0 below (length ag))
	  (setf (aref ag i) (sort (aref ag i) #'(lambda (x y) (declare (type index-type x y)) (< x y))))
	  (iter (for nj in (aref ag i))
		(setf (aref nv (+ (aref fe i) j)) nj)
		(counting t into j)
		(finally (setf (aref fe (1+ i)) (+ (aref fe i) j)))))
    ret))

(defun order->tree (order &optional type)
  (adlist->graph
   (symmetrize!
    (iter (for i from 0 below (length order))
	  (collect (if (/= (aref order i) i) (list (aref order i))) result-type 'vector)))
   type))

(defun cliquep (g lst)
  (iter main (for u* on lst)
    (iter (for v in (cdr u*)) (or (δ-i g (car u*) v) (return-from main nil)))
    (finally (return-from main t))))

(defun gnp (n p)
  (let ((ret (zeros (list n n) '(index-type stride-accessor hash-table))))
    (iter (for i from 0 below n)
	  (iter (for j from (1+ i) below n)
		(if (< (random 1d0) p)
		    (setf (ref ret i j) 1
			  (ref ret j i) 1))))
    (copy ret '(index-type graph-accessor))))

;;Oh may we weep for sins!
(defun moralize! (adg)
  (let ((cadg (make-array (length adg) :initial-element nil)))
    (iter (for u from 0 below (length adg))
	  (iter (for v in (aref adg u))
		(push u (aref cadg v))))
    (iter (for u from 0 below (length adg))
	  (iter (for v in (aref cadg u))
		(setf (aref adg v) (union (aref adg v) (aref cadg u)))))
    adg))

(defun symmetrize! (adg)
  (iter (for u from 0 below (length adg))
	(iter (for v in (aref adg u))
	      (setf (aref adg v) (union (aref adg v) (list u)))))
  adg)
;;
(defun graph-queue (init g)
  (declare (type graph-accessor g))
  (let* ((queue (fib:make-heap #'(lambda (a b) (if (and a b) (< a b) (and a t))))))
    (iter (for i from 0 below (1- (length (fence g)))) (fib:insert-key (funcall init g i) queue))
    queue))

(defmacro graphfib ((g graph &key order iterate block-name) init update &rest body)
  (with-gensyms (fe queue)
    (destructuring-bind (init-sym (i) &rest init-body) init
      (assert (eql init-sym :init) nil "key mismatch.")
      (destructuring-bind (update-sym (j w-j fib) &rest update-body) update
	(assert (eql update-sym :update) nil "key mismatch.")
	`(block ,block-name
	   (let*-typed ((,g ,graph :type graph-accessor)
			(,fe (fence ,g) :type index-store-vector)
			(,fib (let* ((,queue (fib:make-heap ,(or order #'(lambda (a b) (if (and a b) (< a b) (and a t)))))))
				(iter (for ,i from 0 below (1- (length (fence ,g)))) (fib:insert-key (progn ,@init-body) ,queue))
				,queue)))
	     (iter (until (= (total-size fib) 0))
		   ,@(when iterate
			   (letv* (((lvar ldir) iterate))
			     `((for ,lvar initially ,@(ecase ldir (:up `(0 then (1+ ,lvar))) (:down `((- (length ,fe) 2) then (1- ,lvar))))))))
		   (letv* ((,w-j ,j (fib:extract-min ,fib) :type t index-type))
		     ,@update-body))
	     ,@body))))))
;;
(defun max-cardinality-search (g &optional start)
  (let* ((order (t/store-allocator index-store-vector (1- (length (fence g)))))
	 (start (or start (random (length order))))
	 (cliques nil)
	 (k (1- (length (fence g)))) (stack nil))
    (graphfib (g g :order (lambda (x y) (> x y)))
      (:init (i) (if (= i start) 1 0))
      (:update (i w-i fib)
	 (letv* ((li ri (fence g i))
		 (δ-clique (iter (for j in-vector (δ-i g) from li below ri) (when (or (member j stack) (fib:node-existsp j fib)) (collect j)))))
	   (if (cliquep g δ-clique)
	       (iter (for j in-vector (δ-i g) from li below ri) (incf (fib:node-key j fib))
		     (finally (setf (aref order (decf k)) i)
			      (setf cliques (let ((c (list (cons i δ-clique)))) (union cliques (union c cliques :test #'subsetp) :test #'subsetp)))
			      (iter (for u in stack) (fib:insert-key (fib:node-key u fib) fib u) (finally (setf stack nil)))))
	       (push i stack))))
      (unless stack (values (reverse order) cliques)))))

;;Naive-implementation, can't use graphfib because of non-monotonicity
;;Use union-find/hash-table in place of list forc sets.
(defun triangulate-graph (g &optional (heuristic :min-fill))
  (let* ((ag (graph->adlist g))
	 (ord (t/store-allocator index-store-vector (length ag))))
    (flet ((cliquify (u)
	     (iter (for v in (aref ag u))
		   (setf (aref ag v) (set-difference (aref ag v) (list u v))))
	     (setf (aref ag u) t))
	   (δ-size (i) (length (aref ag i)))
	   (k-size (i) (iter main (for u* on (aref ag i))
			     (iter (for v in (cdr u*)) (unless (find (car u*) (aref ag v)) (in main (counting t)))))))
      (iter (for i from 0 below (length ord))
	    (setf (aref ord i) (iter (for i from 0 below (length ag))
				     (unless (eql (aref ag i) t)
				       (finding i minimizing (ecase heuristic (:min-fill (δ-size i)) (:min-size (k-size i)))))))
	    (cliquify (aref ord i))))
    ord))

(defun chordal-cover (g order)
  (declare (type graph-accessor g)
	   (type index-store-vector order))
  (let* ((cc (graph->adlist g))
	 (vs (make-array (length cc) :initial-element nil)))
    (iter (for i in-vector order)
	  (iter (for j in (aref cc i))
		(unless (aref vs j)
		  (setf (aref cc j) (set-difference (union (aref cc j) (remove-if #'(lambda (x) (aref vs x)) (aref cc i))) (list j)))))
	  (setf (aref vs i) t))
    (adlist->graph cc)))

(defun tree-decomposition (g &optional type)
  (letv* ((cliques (or (nth-value 1 (max-cardinality-search g)) (nth-value 1 (max-cardinality-search (chordal-cover g (triangulate-graph g))))))
	  (k (length cliques)))
    (values
     (let ((ret (zeros (list k k) '(index-type stride-accessor hash-table))))
       (iter (for cc on cliques)
	     (iter (for cp in (cdr cc))
		   (counting t into j)
		   (if-let (int (intersection (car cc) cp))
		     (setf (ref ret i (+ i j)) (- (length int))
			   (ref ret (+ i j) i) (ref ret i (+ i j)))))
	     (counting t into i))
       (copy ret '(index-type))
       (order->tree (dijkstra-prims (copy ret '(index-type graph-accessor))) type))
     (coerce cliques 'vector))))

#+nil
(letv* ((ag (symmetrize! #((1) (2) (0 3) (4) (0))))
	(g (adlist->graph ag)))
    ;;(tree-decomposition (chordal-cover g (triangulate-graph g :min-size)))
    ;;(max-cardinality-search g)
    ;;(moralize! #(() (0) (0) (0) (2) (2)))
    ;;(values (copy tt '(index-type)) (dijkstra-prims tt))

    ;;(tree-decomposition ag)  
  (letv* ((tt ci (tree-decomposition g)))
    (graph->adlist tt)
    )
  )

#+nil
(let* ((n 100)
       (n-cycle (symmetrize! (coerce (append (mapcar #'list (range 1 n :list-output? t)) (list '(0))) 'vector)))
       (g (adlist->graph n-cycle)))
  (letv* ((tt ci (time (tree-decomposition g))))
    t
    ))

#+nil
(let ((g (gnp 1000 0.1)))
  (time (tree-decomposition g)))
#+nil
(let ((g (gnp 100 0.02)))
  (map 'list #'length (nth-value 1 (tree-decomposition g))))

;;
(defun dijkstra (g &optional start)
  (declare (type graph-accessor g))
  (let* ((tree (t/store-allocator index-store-vector (dimensions g 0)))
	 (start (or start (random (length tree)))))
    (setf (aref tree start) start)
    (graphfib (g g :order (lambda (x y) (if (and x y) (< x y) (and x t))))
      (:init (i) (if (= i start) 0 nil))
      (:update (i d-i fib)
	 (letv* ((li ri (fence g i)))
	   (iter (for j in-vector (δ-i g) from li below ri)
		 (when (fib:node-existsp j fib)
		   (let ((d-j+ (+ d-i (if (typep g 'base-tensor) (ref g i j) 1))) (k-j (fib:node-key j fib)))
		     (when (or (not k-j) (< d-j+ k-j))
		       (setf (fib:node-key j fib) d-j+
			     (aref tree j) i)))))))
      tree)))

(defun dijkstra-prims (g &optional start)
  (declare (type graph-accessor g))
  (let* ((tree (t/store-allocator index-store-vector (dimensions g 0)))
	 (start (or start (random (length tree)))))
    (setf (aref tree start) start)
    (graphfib (g g :order (lambda (x y) (if (and x y) (< x y) (and x t))))
      (:init (i) (if (= i start) 0 nil))
      (:update (i w-i fib)
	 (letv* ((li ri (fence g i)))
	   (iter (for j in-vector (δ-i g) from li below ri)
		 (when (fib:node-existsp j fib)
		   (let ((w-ij (if (typep g 'base-tensor) (ref g i j) 1)) (k-j (fib:node-key j fib)))
		     (when (or (not k-j) (< w-ij k-j))
		       (setf (fib:node-key j fib) w-ij
			     (aref tree j) i)))))))
      tree)))

#+nil(defparameter *wiki-graph* (copy (let ((mat (zeros '(6 6) '(index-type stride-accessor hash-table))))
				   (map nil #'(lambda (x)
						(destructuring-bind (i j w) x
						    (setf (ref mat i j) w
							  (ref mat j i) w)))
					'((0 1 7)
					  (0 2 9)
					  (0 5 14)
					  (1 2 10)
					  (1 3 15)
					  (2 5 2)
					  (2 3 11)
					  (3 4 6)
					  (4 5 9)))
				   mat)
				 '(index-type graph-accessor)))
;;
