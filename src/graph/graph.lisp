(in-package #:matlisp)

(defun degree (g)
  (with-memoization ()
    (iter (for i from 0 below (1- (length (memoizing (fence g) :type index-store-vector :global t))))
	  (with ret = (t/store-allocator index-store-vector (1- (length (memoizing (fence g) :global t)))))
	  (setf (aref ret i) (-  (aref (memoizing (fence g) :global t) (1+ i)) (aref (memoizing (fence g) :global t) i)))
	  (finally (return ret)))))
;;
(closer-mop:defgeneric graph->adlist (g &optional encode-valuesp)
  (:generic-function-class tensor-method-generator))

(define-tensor-method graph->adlist ((g graph-accessor :x) &optional encode-valuesp)
  `(with-memoization ()
     (iter (for i from 0 below (1- (length (memoizing (fence g) :type index-store-vector :global t)))) (with ret = (make-array (1- (length (memoizing (fence g) :global t))) :initial-element nil))
	   (iter (for j in-vector (memoizing (neighbors g) :type index-store-vector :global t) from (aref (memoizing (fence g) :global t) i) below (aref (memoizing (fence g) :global t) (1+ i)) with-index m)
		 (push ,@(if (subtypep (cl :x) 'tensor) `((if encode-valuesp (cons j (t/store-ref ,(cl :x) (memoizing (t/store ,(cl :x) g) :type ,(store-type (cl :x)) :global t) m)) j)) `(j)) (aref ret i)))
	   (finally (return ret)))))

(defun adlist->graph (ag &optional type &aux (type (or type 'graph-accessor)))
  (let*-typed ((ag (coerce ag 'vector))
	       (ret (zeros (list (length ag) (length ag)) type (iter (for ai in-vector ag) (summing (length ai)))) :type graph-accessor))
    (with-memoization ()
      (iter (for i from 0 below (length ag))
	    (initially (setf (aref (memoizing (fence ret) :type index-store-vector :global t) 0) 0))
	    (setf (aref (memoizing (fence ret) :global t) (1+ i)) (aref (memoizing (fence ret) :global t) i))
	    (iter (for u in (setf (aref ag i) (sort (aref ag i) #'< :key #'(lambda (x) (etypecase x (cons (the index-type (first x))) (index-type x))))))
		  (letv* ((u/ value (etypecase u (cons (the index-type (values (first u) (cdr u)))) (index-type u)))
			  (m (aref (memoizing (fence ret) :global t) (1+ i))))
		    (setf (aref (memoizing (neighbors ret) :type index-store-vector :global t) m) (modproj u/ (length ag) nil))
		    (if value (setf (store-ref (the graph-tensor ret) m) value)))
		  (incf (aref (memoizing (fence ret) :global t) (1+ i))))))
    ret))

(defun hyper->bipartite (hh &optional type full)
  (letv* ((vv (coerce (sort (reduce #'union hh) #'<) 'index-store-vector)) (hh (coerce hh 'vector))
	  (n (length vv)) (m (length hh)))
    (if full
	(let ((hh (symmetrize! (concatenate 'vector (make-array n :initial-element nil) hh))))
	  (adlist->graph hh))
	(let ((ret (zeros (list n m) (or type 'graph-accessor) (iter (for h in-vector hh) (summing (length h))))))
	  (iter (for i from 0 below (length hh))
		(setf (aref hh i) (sort (aref hh i) #'<))
		(iter (for u in (aref hh i))
		      (setf (aref (neighbors ret) (+ (fence ret i) j)) u) (counting t into j)
		      (finally (setf (aref (fence ret) (1+ i)) (+ (fence ret i) j)))))
	  ret))))

(defun symmetrize! (adg)
  (iter (for u from 0 below (length adg))
	(iter (for v in (aref adg u))
	      (setf (aref adg v) (union (aref adg v) (list u)))))
  adg)

(defun moralize! (adg)
  (let ((cadg (copy adg)))
    (iter (for u from 0 below (length adg))
	  (let ((pa (remove-if #'(lambda (x) (find u (aref adg x))) (aref adg u))))
	    (iter (for p.i in pa) (setf (aref cadg p.i) (union (aref cadg p.i) (list* u pa))))))
    cadg))

(defun order->tree (order &optional type symmetricp)
  (adlist->graph
   (funcall (if symmetricp #'symmetrize! #'identity)
     (iter (for i from 0 below (length order))
	   (collect (remove-duplicates (list i (aref order i))) result-type 'vector)))
   type))

(defun cliquep (g lst)
  (iter main (for u* on lst)
    (iter (for v in (cdr u*)) (or (neighbors g (car u*) v) (return-from main nil)))
    (finally (return-from main t))))

(defun topological-order (dag)
  (let ((dagt (transpose dag))
	(order (t/store-allocator index-store-vector (dimensions dag -1)))
	(visited (make-array (dimensions dag -1) :element-type 'boolean :initial-element nil)))
    (iter outer (for cu in-vector visited with-index u) (with ii = -1)
	  (unless cu
	    (iter (for tu in-graph dag from u in-order :sfd with-parent tp with-color color with-visited-array visited)
		  (setf (aref order (incf ii)) tu)
		  (when (some #'(lambda (x) (aref color x)) (neighbors dagt tu t))
		    (return-from outer))))
	  (finally (return-from outer order)))))

(defun graph-queue (init g)
  (declare (type graph-accessor g))
  (let* ((queue (fib:make-heap #'(lambda (a b) (if (and a b) (< a b) (and a t))))))
    (iter (for i from 0 below (1- (length (fence g)))) (fib:insert-key (funcall init g i) queue))
    queue))

(defmacro graphfib ((g graph &key order iterate block-name) init update &rest body)
  (with-gensyms (fe queue)
    (destructuring-bind (init-sym (i) &rest init-body) init
      (assert (eql init-sym :init) nil "key mismatch.")
      (destructuring-bind (update-sym (j w-j fib) &rest update-body) update
	(assert (eql update-sym :update) nil "key mismatch.")
	`(block ,block-name
	   (let*-typed ((,g ,graph :type graph-accessor)
			(,fe (fence ,g) :type index-store-vector)
			(,fib (let* ((,queue (fib:make-heap ,(or order #'(lambda (a b) (if (and a b) (< a b) (and a t)))))))
				(iter (for ,i from 0 below (1- (length (fence ,g)))) (fib:insert-key (progn ,@init-body) ,queue))
				,queue)))
	     (iter (until (= (total-size ,fib) 0))
		   ,@(when iterate
			   (letv* (((lvar ldir) iterate))
			     `((for ,lvar initially ,@(ecase ldir (:up `(0 then (1+ ,lvar))) (:down `((- (length ,fe) 2) then (1- ,lvar))))))))
		   (letv* ((,w-j ,j (fib:extract-min ,fib) :type t index-type))
		     ,@update-body))
	     ,@body))))))

(defun dijkstra (g &optional start)
  (declare (type graph-accessor g))
  (let* ((tree (t/store-allocator index-store-vector (dimensions g 0)))
	 (start (or start (random (length tree)))))
    (setf (aref tree start) start)
    (graphfib (g g :order (lambda (x y) (if (and x y) (< x y) (and x t))))
      (:init (i) (if (= i start) 0 nil))
      (:update (i d-i fib)
	 (letv* ((li ri (fence g i)))
	   (iter (for j in-vector (neighbors g) from li below ri)
		 (when (fib:node-existsp j fib)
		   (let ((d-j+ (+ d-i (if (typep g 'base-tensor) (ref g i j) 1))) (k-j (fib:node-key j fib)))
		     (when (or (not k-j) (< d-j+ k-j))
		       (setf (fib:node-key j fib) d-j+
			     (aref tree j) i)))))))
      tree)))

(defun dijkstra-prims (g &optional start)
  (declare (type graph-accessor g))
  (let* ((tree (t/store-allocator index-store-vector (dimensions g 0)))
	 (start (or start (random (length tree)))))
    (iter (for i from 0 below (length tree)) (setf (aref tree i) i))
    (graphfib (g g :order (lambda (x y) (if (and x y) (< x y) (and x t))))
      (:init (i) (if (= i start) 0 nil))
      (:update (i w-i fib)
	 (letv* ((li ri (fence g i)))
	   (iter (for j in-vector (neighbors g) from li below ri)
		 (when (fib:node-existsp j fib)
		   (let ((w-ij (if (typep g 'base-tensor) (ref g i j) 1)) (k-j (fib:node-key j fib)))
		     (when (or (not k-j) (< w-ij k-j))
		       (setf (fib:node-key j fib) w-ij
			     (aref tree j) i)))))))
      tree)))

(defun directed-subgraph (g)
  (let ((adg (graph->adlist g)))
    (iter (for u from 0 below (length adg)) (setf (aref adg u) (remove-if #'(lambda (x) (declare (type index-type x u)) (neighbors g x u)) (aref adg u))))
    (adlist->graph adg (class-of g))))

(defun max-dag (g)
  "1/2 approximation to the Maximum acyclic subgraph problem (anything better is NP-hard assuming UGC)."
  (let* ((g (directed-subgraph g)) (gt (transpose g))
	 (adg (make-array (dimensions g -1) :initial-element nil)))
    (graphfib (g g :order #'(lambda (a b) (< (first a) (first b))))
      (:init (i) (list (neighbors g i :size) (neighbors gt i :size)))
      (:update (i d-i fib)
	 (map nil #'(lambda (v) (when (fib:node-existsp v fib)
				  (letv* (((a b) (fib:node-key v fib)))
				    (setf (fib:node-key v fib) (list (1- a) b)))))
	      (neighbors gt i t))
	 (map nil #'(lambda (v) (when (fib:node-existsp v fib)
				  (letv* (((a b) (fib:node-key v fib)))
				    (setf (fib:node-key v fib) (list a (1- b))))))
	      (neighbors g i t))
	 (if (>= (first d-i) (second d-i))
	     (map nil #'(lambda (v) (if (fib:node-existsp v fib) (pushnew v (aref adg i)))) (neighbors g i t))
	     (map nil #'(lambda (v) (if (fib:node-existsp v fib) (pushnew i (aref adg v)))) (neighbors gt i t))))
      (adlist->graph adg (type-of g)))))

(defun line-graph (hh)
  (letv* ((hh (coerce hh 'vector)) (m (length hh))
	  (ret (zeros (list m m) (tensor t 'hash-tensor))))
    (iter (for i from 0 below (length hh))
	  (iter (for j from (1+ i) below (length hh))
		(when-let ((int (intersection (aref hh i) (aref hh j))))
		  (setf (ref ret i j) int
			(ref ret j i) int))))
    (copy ret '(t graph-accessor))))
