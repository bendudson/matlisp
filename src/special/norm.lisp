(in-package :matlisp)

(defgeneric norm (vec &optional n))
(define-tensor-method norm ((vec dense-tensor :x) &optional (n 2))
  (let ((rtype (field-type (realified-type (cl vec)))))
    `(cond
       ((typep n 'real)
	(let-typed ((sum (t/fid+ ,rtype) :type ,rtype))
	  (dorefs (idx (dimensions vec))
		  ((ref vec :type ,(cl vec)))
		  (setf sum (t/f+ ,rtype sum (expt (abs ref) n))))
	  (expt sum (/ n))))
       ((eql n :sup)
	(tensor-foldl ,(cl vec) max vec (t/fid+ ,rtype) :init-type ,rtype :key cl:abs)))))

(defgeneric tensor-max (vec &optional key))
(define-tensor-method tensor-max ((vec dense-tensor :x) &optional key)
  `(if key
       (let* ((ridx (make-list (order vec) :initial-element 0))
	      (rval (funcall key (ref vec ridx))))
	 (dorefs (idx (dimensions vec))
		 ((ref vec :type ,(cl vec)))
	   (let ((kval (funcall key ref)))
	     (when (> kval rval)
	       (setf rval kval)
	       (lvec->list! idx ridx))))
	 (values rval ridx))
       (let*-typed ((ridx (make-list (order vec) :initial-element 0))
		    (rval (apply #'ref (list* vec ridx)) :type ,(field-type (cl vec))))
	 (dorefs (idx (dimensions vec))
		 ((ref vec :type ,(cl vec)))
	   (let-typed ((r ref :type ,(field-type (cl vec))))
	     (when (> r rval)
	       (setf rval r)
	       (lvec->list! idx ridx))))
	 (values rval ridx))))

(defgeneric tensor-min (vec &optional key))
(define-tensor-method tensor-min ((vec dense-tensor :x) &optional key)
    `(if key
       (let* ((ridx (make-list (order vec) :initial-element 0))
	      (rval (funcall key (ref vec ridx))))
	 (dorefs (idx (dimensions vec))
		 ((ref vec :type ,(cl vec)))
	   (let ((kval (funcall key ref)))
	     (when (< kval rval)
	       (setf rval kval)
	       (lvec->list! idx ridx))))
	 (values rval ridx))
       (let*-typed ((ridx (make-list (order vec) :initial-element 0))
		    (rval (apply #'ref (list* vec ridx)) :type ,(field-type (cl vec))))
	 (dorefs (idx (dimensions vec))
		 ((ref vec :type ,(cl vec)))
	   (let-typed ((r ref :type ,(field-type (cl vec))))
	     (when (< r rval)
	       (setf rval r)
	       (lvec->list! idx ridx))))
	 (values rval ridx))))

(defun tr (mat)
  (sum (tricopy! mat (zeros (lvec-min (dimensions mat)) (class-of mat)) :d)))
