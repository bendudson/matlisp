(in-package :matlisp)

(closer-mop:defgeneric norm (vec &optional n)
  (:generic-function-class tensor-method-generator))
(define-tensor-method norm ((vec dense-tensor :x) &optional (n 2))
  (let ((rtype (field-type (realified-type (cl :x)))))
    `(cond
       ((typep n 'real)
	(let-typed ((sum (t/fid+ ,rtype) :type ,rtype))
	  (dorefs (idx (dimensions vec))
		  ((ref vec :type ,(cl :x)))
		  (setf sum (t/f+ ,rtype sum (expt (abs ref) n))))
	  (expt sum (/ n))))
       ((eql n :sup)
	(tensor-foldl ,(cl :x) max vec (t/fid+ ,rtype) :init-type ,rtype :key cl:abs)))))

(closer-mop:defgeneric tensor-max (vec &optional key)
  (:generic-function-class tensor-method-generator))
(define-tensor-method tensor-max ((vec dense-tensor :x) &optional key)
  `(if key
       (let* ((ridx (make-list (order vec) :initial-element 0))
	      (rval (funcall key (ref vec ridx))))
	 (dorefs (idx (dimensions vec))
	   ((ref vec :type ,(cl :x)))
	   (let ((kval (funcall key ref)))
	     (when (> kval rval)
	       (setf rval kval)
	       (lvec->list! idx ridx))))
	 (values rval ridx))
       (let*-typed ((ridx (make-list (order vec) :initial-element 0))
		    (rval (apply #'ref (list* vec ridx)) :type ,(field-type (cl :x))))
	 (dorefs (idx (dimensions vec))
		 ((ref vec :type ,(cl :x)))
	   (let-typed ((r ref :type ,(field-type (cl :x))))
	     (when (> r rval)
	       (setf rval r)
	       (lvec->list! idx ridx))))
	 (values rval ridx))))

(closer-mop:defgeneric tensor-min (vec &optional key)
  (:generic-function-class tensor-method-generator))
(define-tensor-method tensor-min ((vec dense-tensor :x) &optional key)
    `(if key
       (let* ((ridx (make-list (order vec) :initial-element 0))
	      (rval (funcall key (ref vec ridx))))
	 (dorefs (idx (dimensions vec))
		 ((ref vec :type ,(cl :x)))
	   (let ((kval (funcall key ref)))
	     (when (< kval rval)
	       (setf rval kval)
	       (lvec->list! idx ridx))))
	 (values rval ridx))
       (let*-typed ((ridx (make-list (order vec) :initial-element 0))
		    (rval (apply #'ref (list* vec ridx)) :type ,(field-type (cl :x))))
	 (dorefs (idx (dimensions vec))
		 ((ref vec :type ,(cl :x)))
	   (let-typed ((r ref :type ,(field-type (cl :x))))
	     (when (< r rval)
	       (setf rval r)
	       (lvec->list! idx ridx))))
	 (values rval ridx))))

(defun tr (mat)
  (sum (tricopy! mat (zeros (lvec-min (dimensions mat)) (class-of mat)) :d)))
