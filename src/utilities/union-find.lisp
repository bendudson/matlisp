(in-package #:matlisp-union-find)

(closer-mop:defclass union-find ()
  ((setid :initform (make-extensible-array))
   (subtree :initform (make-extensible-array))
   (values :initarg :values :initform (make-extensible-array))
   (index :initform (make-hash-table))))

(closer-mop:defmethod print-object ((obj union-find) stream)
  (print-unreadable-object (obj stream :type t)
    (format stream "size: ~A" (length (slot-value obj 'setid)))))

(closer-mop:defmethod initialize-instance :after ((obj union-find) &rest initargs)
  (declare (ignore initargs))
  (when (listp (slot-value obj 'values))
    (let ((vv (slot-value obj 'values)))
      (setf (slot-value obj 'values) (make-extensible-array))
      (iter (for vi in vv) (index vi obj)))))

(defun index (item ufd)
  (gethash! item (slot-value ufd 'index)
      (let ((id (slot-value ufd 'setid)))
	(vector-push-extend item (slot-value ufd 'values))
	(vector-push-extend (length id) id)
	(vector-push-extend nil (slot-value ufd 'subtree)))))

(defun root (i ufd)
  (let ((id (slot-value ufd 'setid)))
    (iter (for ui initially i then (aref id ui))
	  (if (= ui (aref id ui)) (return ui))
	  ;;path-compression
	  (setf (aref id ui) (aref id (aref id ui))))))

(defun unify (i j ufd)
  (let ((rj (root j ufd)) (ri (root i ufd))
	(id (slot-value ufd 'setid))
	(stree (slot-value ufd 'subtree)))
    (unless (= ri rj)
      (push ri (aref stree rj))
      (iter (with ui = i)
	    (let ((ui+ (aref id ui)))
	      (setf (aref id ui) rj)
	      (if (/= ui ui+) (setf ui ui+) (finish))))))
  ufd)

(defun subset (i ufd)
  (let ((stree (slot-value ufd 'subtree))
	(values (slot-value ufd 'values))
	(stack (list (root i ufd))))
    (iter :l1 (for ui next (if stack (pop stack) (finish)))
	  (let ((sub (aref stree ui)))
	    (setf stack (append stack sub))
	    (if (first-time-p) (collect (aref values ui)))
	    (iter (for idx in sub) (in :l1 (collect (aref values idx))))))))
